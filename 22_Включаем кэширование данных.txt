урок
https://www.youtube.com/watch?v=Z3kry8telRo&list=PLA0M1Bcd0w8xO_39zZll2u1lz_Q-Mwn1F&index=22

О кэшировании: https://djbook.ru/rel3.0/topics/cache.html

При повторном обращении к данным берем их из КЕШа
_________________________________________________________

                Кеширование на основе файлов - самое частое использование
            1. на сайте документации "Кэширование на файловую систему" копируем код для win
                CACHES = {
                    'default': {
                        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
                        'LOCATION': 'путь до папки кеша',
                    }
                }
            2. вставляем его в settings.py и в 'LOCATION' нужно указать путь до папки кеша
        'LOCATION': os.path.join(BASE_DIR, 'coolsite_cache'),
        где "BASE_DIR" - хранит каталог проекта,  'coolsite_cache' - папка кеша и создаем ее в корне нашего проекта

            3. Чаще кешируется-> "Кэширование на уровне представлений" (https://djbook.ru/rel3.0/topics/cache.html#the-per-view-cache)
            -Будем делать на уровне классов
            3.1. в "urls.py" импортируем "from django.views.decorators.cache import cache_page"
        - добавляем декоратор в url нашей главной страницы
            cache_page(60)(WomenHome.as_view()) , где 60 это в секундах время хранения кеша
        запускаем сервер ,
        обновляем "Главную страницу"-создается кеш в папке"coolsite_cache",
        при повторном обновлении "Главной страницы" она загружается из кеша и не делает SQL запросов
        после 60сек она снова будет загружаться с запросами SQL

-------------------------для следующего шага отменим изменения-------------------------------------------

            3.2. Кеширование на уровне ШАБЛОНОВ  "Кэширование фрагментов шаблона" - https://djbook.ru/rel3.0/topics/cache.html#template-fragment-caching
        - в base.html есть <!-- Sidebar слева --> в этом блоке цикл {% for c in cats %}
            cats - берется из базы данных , вот его и закешируем
        - в блоке <!-- Sidebar слева --> пропишем загрузку
                            {% load cache %}
        - перед формированием "Sidebar" ниже "<ul id="leftchapters">" пропишем
                            {% cache 60 sidebar %}
        - после формирования "Sidebar" пропишем
                            {% endcache %}

-------------------------для следующего шага отменим изменения-------------------------------------------

            4. Кеширование при помощи "API низкого уровня для кэширования" - https://djbook.ru/rel3.0/topics/cache.html#the-low-level-cache-api

            * cache.set() - сохранение произвольных данных в кэш по ключу;
            * cache.get() - выбор произвольных данных из кэша по ключу;
            * cache.add() - заносит новое значение в кеш, если его там еще нет (иначе данная операция игнорируется;
            * cache.get_or_set() - извлекает данные из кэша, если их нет, то автоматически заносится значение по умолчанию;
            * cache.delete() - удаление данных из кэша по ключу;
            * cache.clear() - полная очистка кеша.

            4.1. в файле utils.py - импортируем - from django.core.cache import cache
        - в "class DataMixin" в "def get_user_context" пропишем
    cats = cache.get('cats')
    if not cats:
        cats = Category.objects.annotate(Count('women'))  # формируем список категорий Агрегурующей функцией
        cache.set('cats', cats, 60)

    КЕШИРОВАНИЕ ВКЛЮЧАТЬ ТОЛЬКО НА КОНЕЧНОМ ЭТАПЕ РАЗРАБОТКИ САЙТОВ,
чтобы в процессе програмирования могли отслеживать все нагрузки которые происходят при формировании ответов к серверу
кширование может скрывать какие либо отдельные SQL запросы











