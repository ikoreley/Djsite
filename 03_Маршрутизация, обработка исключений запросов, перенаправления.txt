!!!!!!______
сделаем правку откроем файл пакета coolsite\urls.py
в списке urlpatterns => path('women/', include('women.urls')) уберем префикс 'women/' сделаем => path('', include('women.urls'))
и все маршруты будут расчитываться от ДОМЕННОГО имени

сделаем отображение страниц категорий по индексу
path('cats/<int:catid>/', categories) # catid - произвольное имя
шаблон - 'cats/<int:catid>/' - префикс/число инт/
далее перходим в пакет women в файл views.py и добавляем второй атрибут(catid) функции def categories(request, catid)
корректируем вывод=> return HttpResponse(f"<h1>Статьи по категориям</h1><p>{catid}</p>")
на странице видим заголовок "Статьи по категориям" и цифру категории "catid"
ТЕПЕРЬ к странице можно обратится только как указали в шаблоне http://127.0.0.1:8000/cats/1/ (1 это catid)
остальное обращение выдаст ошибку
_______________________________________________________________________
в шаблонах 'cats/<int:catid>/ может указываться

str - любая непустая строка, исключая '/';
int - любое положительное число, включая 0;
slug - слаг, т.е. латиница ASCII таблицы, символы дефиса и подчеркивания;
uuid - цифры, малые латинские символы ASCII, дефис;
path - любая не пустая строка, включая символ '/'
_________________________________________________________________________

если таких шаблонов недостаточно то можно использовать шаблоны с помощью регулярных выражений
re_path()
пример: re_path(r'^archive/(?P<year>[0-9]{4})/', archive)
начинаеися с ^archive/ - именованный параметр <year> - год из 4 цифр ЭТО ОБЯЗАТЕЛЬНЫЙ параметр указанный в шаблоне
пропишем в пакет women в файл views.py функцию def archive(request, year)
введем адрес http://127.0.0.1:8000/archive/2020/ и получим "Архив по годам" и следующая строка "2020"
http://127.0.0.1:8000/archive/здесь обязательно 4 цифры, остальное выдаст ошибку/

___
ОБРАБОТКА GET и POST запросов
( ПРИМЕР GET запросов => http://127.0.0.1:8000/?name=Gagarina&cat=music ,
                         http://127.0.0.1:8000/cats/music/?name=Gagarina&type=pop )
в пакет women в файл views.py в функции def categories(request, catid):
пропишем GET запрос => print(request.GET)
введем http://127.0.0.1:8000/cats/1/?name=Gagarina&type=pop
и в терминал print(request.GET) выведет <QueryDict: {'name': ['Gagarina'], 'type': ['pop']}>

можно прописать условие if request.GET: print(request.GET) , что означает если будет запрос принтанет словарь QueryDict
c get запросом http://127.0.0.1:8000/cats/1/?name=Gagarina&type=pop
БЕЗ get запросом http://127.0.0.1:8000/cats/1/ , словарь будет пуст и принт ничего не выведет

ВСЕ ПО АНАЛОГИИ можно работать и с POST запросом

___
Обработка исключений при запросах к серверу-------------------
при запросе на несуществующую страницу выдаст ошибку 404 , это все мы видим в процесссе отладки, и находится
в файле settings.py
# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True
для примера отключим режим дебага сделаем DEBUG = False и пропишим адреса хостов ALLOWED_HOSTS = ['127.0.0.1']
так мы открываем сайт в обычном режиме и несуществующая страница выдаст
"Not Found" "The requested resource was not found on this server."

напишем специальный обработчик страниц 404
в файле coolsite/urls.py пропишем специальную переменную  handler404 = pageNotFound присваиваем функцию обработчик и ее надо написать
пропишем функцию в women/views.py
def pageNotFound(request, exception):
    return HttpResponseNotFound('<h1>Страница не найдена</h1>')
и при несуществующей страницы выдаст "Страница не найдена"
=> далее в функции def archive(request, year): можем прописать исключение if int(year) > 2021: raise Http404()
и если год будет больше 2021 то выведет "Страница не найдена" т.е. отработает функция pageNotFound
# т.е. когда генерируется исключение 'raise Http404()' оно автоматически попадает в pageNotFound в атрибут exception
=>
Аналогичным образом можно переопределять обработчики других исключений
handler500 - ошибка сервера;
handler403 - доступ запрещен;
handler400 - невозможно обработать запрос.
=> все эти обработчики начинают работать когда=> DEBUG = False ( в файле settings.py почитать https://djbook.ru/rel3.0/topics/http/views.html)
при DEBUG = True будем видеть расширенную служебную тнформацию помогающую исправлять ошибки при разработке сайта

при проблемах приложения  ПЕРЕГРУЗИ СЕРВЕР

_____
Создание редиректов 301 и 302 (довольно часто приходитсчя использовать при разработке сайтов)
301 - страница перемещена на другой постоянный URL-адрес;
302 - страница перемещена временно на другой URL-адрес.
для этого используется функция redirect => django.shortcuts.redirect
=>302
women/views.py в функции def archive(request, year): сделаем редирект if int(year) > 2021: return redirect('/')
при запросе года более 2021 перекинет на главную страницу  "Страница приложения women." (http://127.0.0.1:8000/)
=>301
для постоянно редиректа нужно дописать  => return redirect('/', permanent=True)
=> !!! ЯВНО ПРОПИСЫВАТЬ '/' URL-адрес хардкодинг т.е. ТАК НЕ СТОИТ ДЕЛАТЬ!!!
лучше прописать подобно-> return redirect('home', permanent=True) - 'home'  имя нашей главной страницы (сами называем)
и прописываем в women/urls.py маршрут-> path('', index, name='home') и нашему маршруту присваивается имя 'home'













